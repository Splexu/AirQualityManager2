/**
 * @file MapWidget.cpp
 * @brief Implementation of the MapWidget class.
 * @author Generated by Grok
 * @date 2025-04-22
 *
 * Contains the implementation of the MapWidget class, which displays a map
 * with interactive station markers.
 */

#include "MapWidget.h"
#include <QPainter>
#include <QMouseEvent>
#include <QMessageBox>
#include <QDebug>
#include <cmath>

/**
 * @brief Constructor for MapWidget.
 * @param stations List of stations to display.
 * @param offline Offline measurement data.
 * @param online Online measurement data.
 * @param parent Parent widget, defaults to nullptr.
 *
 * Initializes the map image, markers, and UI components.
 */
MapWidget::MapWidget(const QList<Station> &stations,
                     const QMap<int, QList<Measurement>> &offline,
                     const QMap<int, QList<Measurement>> &online,
                     QWidget *parent)
    : QWidget(parent), mapImage(":/resources/poland_map.png"),
    offlineMeasurements(offline), onlineMeasurements(online), mapLoaded(false) {
    setMinimumSize(800, 600);
    setMouseTracking(true);

    if (mapImage.isNull()) {
        qDebug() << "Error: Failed to load poland_map.png";
    } else {
        qDebug() << "Success: poland_map.png loaded, size:" << mapImage.size();
        mapLoaded = true;
    }

    if (mapLoaded) {
        initializeMarkers(stations);
    }

    closeMapButton = new QPushButton("Zamknij mapę", this);
    connect(closeMapButton, &QPushButton::clicked, this, &MapWidget::onCloseMapClicked);

    layout = new QVBoxLayout(this);
    layout->setContentsMargins(10, 10, 10, 10);
    layout->addStretch();
    layout->addWidget(closeMapButton, 0, Qt::AlignHCenter);
    layout->addSpacing(10);
}

/**
 * @brief Paints the map and station markers.
 * @param event Paint event.
 */
void MapWidget::paintEvent(QPaintEvent *event) {
    QPainter painter(this);
    painter.setRenderHint(QPainter::Antialiasing);

    if (!mapLoaded) {
        painter.fillRect(rect(), Qt::gray);
        painter.setPen(Qt::red);
        painter.drawText(rect(), Qt::AlignCenter, "Failed to load map image");
        return;
    }

    painter.drawPixmap(0, 0, width(), height(), mapImage);

    for (const auto &marker : markers) {
        double xRatio = marker.position.x() / mapImage.width();
        double yRatio = marker.position.y() / mapImage.height();
        QPointF scaledPos(xRatio * width(), yRatio * height());

        painter.setPen(Qt::black);
        painter.setBrush(Qt::red);
        painter.drawEllipse(scaledPos, 5, 5);
    }
}

/**
 * @brief Handles mouse clicks to select stations.
 * @param event Mouse event.
 */
void MapWidget::mousePressEvent(QMouseEvent *event) {
    if (!mapLoaded) {
        return;
    }

    for (const auto &marker : markers) {
        double xRatio = marker.position.x() / mapImage.width();
        double yRatio = marker.position.y() / mapImage.height();
        QPointF scaledPos(xRatio * width(), yRatio * height());

        if ((event->pos() - scaledPos).manhattanLength() < 10) {
            showStationInfo(marker.station);
            break;
        }
    }
}

/**
 * @brief Converts latitude and longitude to pixel coordinates on the map.
 * @param latitude Latitude in degrees.
 * @param longitude Longitude in degrees.
 * @return Pixel position on the map.
 */
QPointF MapWidget::latLonToPixel(double latitude, double longitude) {
    if (!mapLoaded) {
        return QPointF(0, 0);
    }

    const double minLat = 49.0, maxLat = 54.8;
    const double minLon = 14.1, maxLon = 24.1;

    double xRatio = (longitude - minLon) / (maxLon - minLon);
    double yRatio = 1.0 - (latitude - minLat) / (maxLat - minLat);

    double x = xRatio * mapImage.width();
    double y = yRatio * mapImage.height();

    return QPointF(x, y);
}

/**
 * @brief Displays a dialog with station information and option to view data.
 * @param station The selected station.
 */
void MapWidget::showStationInfo(const Station &station) {
    QMessageBox::StandardButton reply = QMessageBox::question(
        this,
        "Wyświetl dane",
        QString("Czy chcesz zobaczyć dane dla stacji %1?").arg(station.name),
        QMessageBox::Yes | QMessageBox::No
        );

    if (reply == QMessageBox::Yes) {
        emit stationSelected(station.id);
        close();
    }
}

/**
 * @brief Analyzes measurements by parameter and returns a formatted string.
 * @param measurements List of measurements to analyze.
 * @return Formatted analysis string.
 */
QString MapWidget::analyzeMeasurementsByParameter(const QList<Measurement> &measurements) {
    QStringList analysisLines;

    QMap<QString, QList<Measurement>> measurementsByParam;
    for (const auto &m : measurements) {
        measurementsByParam[m.paramName].append(m);
    }

    for (auto it = measurementsByParam.constBegin(); it != measurementsByParam.constEnd(); ++it) {
        const QString paramName = it.key();
        const QList<Measurement> paramMeasurements = it.value();

        if (paramMeasurements.isEmpty()) {
            analysisLines << QString("Parametr %1: Brak danych.").arg(paramName);
            continue;
        }

        double minValue = paramMeasurements.first().value;
        double maxValue = paramMeasurements.first().value;
        QDateTime minDateTime = paramMeasurements.first().dateTime;
        QDateTime maxDateTime = paramMeasurements.first().dateTime;
        double sum = 0.0;
        int validCount = 0;

        for (const auto &m : paramMeasurements) {
            if (m.value >= 0) {
                if (m.value < minValue) {
                    minValue = m.value;
                    minDateTime = m.dateTime;
                }
                if (m.value > maxValue) {
                    maxValue = m.value;
                    maxDateTime = m.dateTime;
                }
                sum += m.value;
                validCount++;
            }
        }

        double average = (validCount > 0) ? sum / validCount : 0.0;

        double trend = 0.0;
        if (validCount > 1) {
            double sumX = 0.0, sumY = 0.0, sumXY = 0.0, sumXX = 0.0;
            int i = 0;
            for (const auto &m : paramMeasurements) {
                if (m.value >= 0) {
                    double x = i;
                    double y = m.value;
                    sumX += x;
                    sumY += y;
                    sumXY += x * y;
                    sumXX += x * x;
                    i++;
                }
            }
            double n = validCount;
            trend = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
        }

        analysisLines << QString("Parametr: %1").arg(paramName);
        analysisLines << QString("- Najmniejsza wartość: %1 (%2)").arg(minValue).arg(minDateTime.toString());
        analysisLines << QString("- Największa wartość: %1 (%2)").arg(maxValue).arg(maxDateTime.toString());
        analysisLines << QString("- Średnia wartość: %1").arg(average, 0, 'f', 2);
        analysisLines << QString("- Trend: %1").arg(trend > 0 ? "Rosnący" : trend < 0 ? "Malejący" : "Stabilny");
        analysisLines << "";
    }

    return analysisLines.join("\n");
}

/**
 * @brief Closes the map widget.
 */
void MapWidget::onCloseMapClicked() {
    close();
}

/**
 * @brief Initializes station markers from the provided stations.
 * @param stations List of stations to initialize.
 */
void MapWidget::initializeMarkers(const QList<Station> &stations) {
    markers.clear();
    for (const auto &s : stations) {
        StationMarker marker;
        marker.station = s;
        marker.position = latLonToPixel(s.latitude, s.longitude);
        markers.append(marker);
    }
}